import numpy as  np
import glob, copy
from tqdm import tqdm
import ipdb
bb = ipdb.set_trace
import cv2
import time
import os
osp = os.path
from io3d import *
from sleeve_segm import getLargestCC, segm_sleeve
from outlier_remove import rm_outlier


import os
import struct
import numpy as np;

class BinaryFileDecoder:
    """This class can be used to convert or decode binary file generated by the ArianaCam native interface. In particular,
       it can convert these to numpy compressed arrays for easier consumption by Python projects
    """
    def __init__(self):
        self.DataTypeUnknown = 0;
        self.DataTypeArianaPointCloud1 = 1;
        self.DataTypeArianaRawDepth1 = 2;
        self.state = 0;
        self.dataType = self.DataTypeUnknown;
        self.readCount = 0;
        self.ReportFormatNone = 0;
        self.ReportFormatArianaCamHandler = 1;
        self.reportFormat = self.ReportFormatNone;
        self.npObject = None;
        self.depthImage = None;

    def readInt(self,fileDescriptor):
        """This method will read a 32-bits int in little endian format from the underlying stream
        """
        b = fileDescriptor.read(4);
        v1 = (b[1]<<8)|b[0];
        v2 = (b[3]<<8|b[2]);
        v = (v2<<16)|v1;
        self.readCount += 4;
        return(v);
    def readFloat(self,fileDescriptor):
        """This method will read a 32-bits float in little endian format from the underlying stream
        """
        b = fileDescriptor.read(4);
        v =  struct.unpack('<f', b)
        self.readCount += 4;
        return(v);

    def readFloatArray(self,f,size):
        """This method will read an array of floats encoded as bytes in little-endian order from the underlying stream
        and return this array as a Python object
        """
        b = f.read(size);
        if(len(b) != size):
            raise RuntimeError("Unable to read %d bytes from the input stream" % size);
        self.readCount += size;

        targetIndex = 0;
        
        R = np.fromstring(b, dtype='<f')
        # equivalent but slower
        #iter = struct.iter_unpack("<f",b);
        #R = [ r[0] for r in iter];

        return(R);
    def readUshortArray(self,f,size):
        """This mtheod will read an array of ushorts encoded as bytes in little-endian order from the underlying stream
        and return this array as a Python object
        """
        b = f.read(size);
        if(len(b) != size):
            raise RuntimeError("Unable to read %d bytes from the input stream" % size);
        self.readCount += size;

        targetIndex = 0;
        
        R = np.fromstring(b, dtype='<H')
        # equivalent but slower
        #iter = struct.iter_unpack("<f",b);
        #R = [ r[0] for r in iter];

        return(R);
    def decode(self,input,output=None,outputFormat="npz",applyDepthScale=True):
        """This method will decode a binary-encoded ArianaCam data file and optionally save the result to file in a format specified by the outputFormat parameter.
        If an output parameter is specified, this is the name of the file where the data will be stored. If the output is not specified, but the outputFormat is 
        npz, the output file name is based on the input file name to which an extension matching the output format is appended.

        If input denotes a directory, the method will recursively process all suitable files in that folder.

        Typically, callers will call *decoder.decode("somefile.pc")* which results in the creation of the output file *somefile.npz*

        Currently, this method handle ArianaCam *pointcloud* and *raw depth* data formats, version 1. More types are likely to be added in the future.
        Note that by default, raw depth messages values, once converted to Numpy arrays, always represent values in 1-meter units, which may differ from the raw values found
        in the data files, because values are scaled based on the
        depth scale parameter found in ArianaCam data file headers.
        """

        if(input is None):
            raise RuntimeError("The input argument cannot be null");
        if(os.path.isdir(input)):
            self.decodeCollection(input,outputFormat);
            return;
        size = os.path.getsize(input);
        self.readCount = 0;
        self.vertices = None;
        self.verticesWidth = None;
        self.verticesHeight = None;
        self.verticesStride = None;
        self.depthImage = None;
        self.npObject = None;
        self.dataType = self.DataTypeUnknown;
        self.state = 0;
        header1 = 0;
        header2 = 0;
        with open(input,"rb") as f:
            while(self.readCount < size):

                # read header first int
                if(self.state == 0):
                    header1 = self.readInt(f);
                    self.state = 1;
                # read header second int
                elif(self.state == 1):
                    header2 = self.readInt(f);
                    if(header1 == 0x2A00 and header2 == 0x0001):
                        self.dataType = self.DataTypeArianaPointCloud1;
                        self.state = 2;
                    elif(header1 == 0x2A01 and header2 == 0x0001):
                        self.dataType = self.DataTypeArianaRawDepth1;
                        self.state = 2;
                    else:
                        raise RuntimeError("Invalid binary data header. Cannot proceed");
                # read data
                else:
                    if(self.dataType == self.DataTypeArianaPointCloud1):
                        if(self.state == 2):
                            self.verticesWidth = self.readInt(f);
                            self.state = 3;
                        elif(self.state == 3):
                            self.verticesHeight = self.readInt(f);
                            self.state = 4;
                        elif(self.state == 4):
                            self.verticesStride = self.readInt(f);
                            self.state = 5;   
                        else:
                            # pc data consists of
                            # an array of floats serialized as bytes. floats are 4 bytes long
                            dataSize = self.verticesStride*self.verticesHeight*4;
                            self.vertices = self.readFloatArray(f,dataSize);
                    elif(self.dataType == self.DataTypeArianaRawDepth1):
                        if(self.state == 2):
                            self.depthDataWidth = self.readInt(f);
                            self.state = 3;
                        elif(self.state == 3):
                            self.depthDataHeight = self.readInt(f);
                            self.state = 4;
                        elif(self.state == 4):
                            self.depthDataStride = self.readInt(f);
                            self.state = 5;   
                        elif(self.state == 5):
                            self.depthScale = self.readFloat(f);
                            self.state = 6;   
                        else:
                            # pc data consists of
                            # an array of floats serialized as bytes. ushors are 2 bytes long
                            dataSize = self.depthDataStride*self.depthDataHeight*2;
                            self.vertices = self.readUshortArray(f,dataSize);

        if(self.dataType == self.DataTypeArianaPointCloud1 or self.dataType == self.DataTypeArianaRawDepth1):
            self.saveArianaData(input,output,outputFormat,applyDepthScale);


    def toNumpy(self,input,applyDepthScale=True):
        """This method will convert the point cloud data stored in the given file, convert it to numpy format and return the numpy array
        """
        self.decode(input,outputFormat="np",applyDepthScale=applyDepthScale);
        return(self.npObject);

    def getNumpy(self):
        """This method will return the numpy representation of the point clould data. The decode() method or the toNumpy()
        method must have beem called prior to calling this method or the returned object will be None.
        """
        return(self.npObject);

    def saveArianaData(self,input,output,outputFormat,applyDepthScale):
        """This method will convert the currently decoded data to various formats and optionally save this to disk.
        Note that if the source data corresponds to depth data, the values are multiplied by the depth scale specified in the data
        header, unless it is 0.
        """
        if(outputFormat == "npz"):
            a = np.array(self.vertices,dtype=np.float);
            a = a.reshape(self.verticesHeight,self.verticesWidth,3);
            if(self.dataType ==  self.DataTypeArianaPointCloud1):
                a = a.reshape(self.verticesHeight,self.verticesWidth,3);
            elif(self.dataType ==  self.DataTypeArianaRawDepth1):
                a = a.reshape(self.depthDataHeight,self.depthDataWidth,1);
                if(applyDepthScale and self.depthScale is not None and self.depthScale != 0):
                    a = a * self.depthScale;
            self.npObject = a;
            if(output is None):
                extIdx = input.rfind(".");
                if(extIdx > 0):
                    output = input[0:extIdx];
                else:
                    output = input;
                output += ".npz";
            np.savez_compressed(output,a);
        # np mode does not save to file, it's used only to convert to np
        elif(outputFormat == "np"):
            a = np.array(self.vertices,dtype=np.float);
            if(self.dataType ==  self.DataTypeArianaPointCloud1):
                a = a.reshape(self.verticesHeight,self.verticesWidth,3);
            elif(self.dataType ==  self.DataTypeArianaRawDepth1):
                a = a.reshape(self.depthDataHeight,self.depthDataWidth,1);
                if(applyDepthScale and self.depthScale is not None and self.depthScale != 0):
                    a = a * self.depthScale;
            self.npObject = a;
        elif(outputFormat == "grayscale"):
            a = np.array(self.vertices,dtype=np.float);
            if(self.dataType ==  self.DataTypeArianaPointCloud1):
                a = a.reshape(self.verticesHeight,self.verticesWidth,3);
            elif(self.dataType ==  self.DataTypeArianaRawDepth1):
                a = a.reshape(self.depthDataHeight,self.depthDataWidth,1);
            Z = a[...,2];
            M = Z.max();
            if(M != 0):
                Z = Z * (255/M);
            if(output is None):
                self.depthImage = Z.astype(np.uint8);

    def decodeCollection(self,root,outputFormat):
        for dirpath,dirnames,filenames in os.walk(root):
            for d in dirnames:
                candidate = os.path.join(dirpath,d);
                self.decodeCollection(candidate);
            for f in filenames:
                candidate = os.path.join(dirpath,f);
                if(not candidate.endswith(".pc")):
                    continue;
                if(self.reportFormat == self.ReportFormatArianaCamHandler):
                    print("ArianaDecoder: #{Processing: %s}#" % f,flush=True);
                self.decode(candidate);
 

    def getDepthImage(self):
        """This method will return the current image. An image conversion method must have been called prior to using this method.
        The actual data may vary, but by default, for pointcloud and raw depth data, this is a grayscale representation of depth without any histogram stretching.
        """
        return(self.depthImage);



def imgs2vid_ffmpeg(imgs_dir, file_pth, ext='png',  frm_rate=10):
    import os
    print(f"ffmpeg creating video...")
    cmd = f"ffmpeg -hide_banner -loglevel error -framerate {frm_rate} -pattern_type glob -i '{imgs_dir}/*.{ext}' -c:v " f"libx264 -vf fps=30 -pix_fmt yuv420p {file_pth} -y "
    os.system(cmd)
    # os.system(f"rm {imgs_dir}/*.jpg")

    return print(f"video saved here: {file_pth}")


class L515DataInterface:
    def __init__(self, inp_seq_dir, save_base_dir, save_rgb=False, save_depth=False,
     save_mask=False, save_pcd=False, pcd_bkgd_rm=False, pcd_with_color=False,
     pcd_with_normals=False, dist_thresh=0.8, crop_slv=False, depth_type='dist_xyz',
     start_ind=None, end_ind=None, slv_clr=None, norm_type=None, kms_max_iter=None,
     kms_eps=None, kms_num_clstrs=None, sqn=None):
        self.inp_seq_dir = inp_seq_dir
        self.save_base_dir = save_base_dir
        self.save_rgb = save_rgb
        self.save_depth = save_depth
        self.save_mask = save_mask
        self.save_pcd  = save_pcd
        self.pcd_bkgd_rm = pcd_bkgd_rm
        self.depth_type = depth_type
        self.pcd_with_color = pcd_with_color
        self.pcd_with_normals = pcd_with_normals
        self.crop_slv = crop_slv
        self.dist_thresh = dist_thresh
        self.start_ind = start_ind
        self.end_ind = end_ind
        self.sqn = sqn

        # sleeve segm parameters
        if slv_clr is not None:
            self.slv_clr = slv_clr
        else:
            raise ValueError("class arg slv_color is None!!")

        if norm_type is not None:
            self.norm_type = norm_type
        else:
            ValueError("class arg norm_type is None!!")
        
        if kms_max_iter is not None:
            self.kms_max_iter = kms_max_iter 
        else:
            raise ValueError("class arg kms_max_iter is None!!")         
        
        if kms_eps is not None:
            self.kms_eps = kms_eps
        else:
            raise ValueError("class arg kms_eps is None!!") 
         
        if kms_num_clstrs is not None:
            self.kms_num_clstrs = kms_num_clstrs 
        else:
            raise ValueError("class arg kms_num_clstrs is None!!")  

    def create_npzs(self,):
        print('Creating npz files..')
        start = time.time()
        raw_imgs_pths = sorted(glob.glob(osp.join(self.inp_seq_dir, 'image', '*.png')))
        assert len(raw_imgs_pths) > 0, f"No .png files in image dir of given seq dir:{self.inp_seq_dir}"
        print('Creating bgr.npz files...')
        for (rimp) in tqdm(raw_imgs_pths):
            im = cv2.imread(rimp)
            fn_bgr = osp.join(self.inp_seq_dir, 'pointcloud', osp.basename(rimp).replace('png', 'bgr.npz'))
            np.savez(fn_bgr, im)

        print('Creating xyz.npz files')
        pcd_bin_pths = sorted(glob.glob(osp.join(self.inp_seq_dir, 'pointcloud', '*.xyz.pc')))
        for pcdbp in tqdm(pcd_bin_pths):
            pcd_arr = BinaryFileDecoder().toNumpy(pcdbp)
            fn_xyz = pcdbp.replace('pc', 'npz')
            np.savez(fn_xyz, pcd_arr)
        print('Done!')
        print(f'npzs Save Time: {(time.time() - start):0.4f}s')
        print(f"rgb save here: {osp.join(self.inp_seq_dir, 'pointcloud')}")

        return None

    def save_rgbs(self,):
        print("Saving rgbs...")
        start = time.time()
        imgs_pths = sorted(glob.glob(osp.join(self.inp_seq_dir, 'pointcloud', '*.bgr.npz')))[self.start_ind : self.end_ind]
        assert len(imgs_pths) > 0, f"No .bgr.npz files in given seq dir:{self.inp_seq_dir}"

        rgb_sdir = osp.join(self.save_base_dir, self._get_seq_name, 'rgb')
        os.makedirs(rgb_sdir, exist_ok=True)

        for (imp) in tqdm(imgs_pths):
            bgr = dict(np.load(imp))['arr_0']    
            fn_rgb = osp.join(rgb_sdir, osp.basename(imp).replace('bgr.npz', 'png'))
            cv2.imwrite(fn_rgb, bgr)
        print('Done!')
        print(f'RGB Save Time: {(time.time() - start):0.4f}s')
        print(f"rgb save here: {rgb_sdir}")
        
        return None

    def save_pcds_from_slvless_img(self,):
        "save poinclouds"
        print('Saving PCDs using slvless imgs...')
        start = time.time()
        # bb()
        pcds_pths = sorted(glob.glob(osp.join(self.inp_seq_dir, 'pointcloud', '*.xyz.npz')))[self.start_ind : self.end_ind]
        assert len(pcds_pths) > 0, f"No .xyz.npz files in given seq dir:{self.inp_seq_dir}"

        slvless_imgs_pths = sorted(glob.glob(osp.join(self.save_base_dir, args.sqn,  'slvless_img', '*.png')))[self.start_ind : self.end_ind]
        assert len(slvless_imgs_pths) > 0, f"No slvless imgs .png files in given dir:{osp.join(self.save_base_dir, args.sqn,  'slvless_img')}"

        imgs_pths = sorted(glob.glob(osp.join(self.inp_seq_dir, 'pointcloud', '*.bgr.npz')))[self.start_ind : self.end_ind]
        assert len(imgs_pths) > 0, f"No .bgr.npz files in given seq dir:{self.inp_seq_dir}"
        
        for (pcdp, imp, slvless_imp) in tqdm(zip(pcds_pths, imgs_pths, slvless_imgs_pths)):
            # bb()
            xyz_raw = dict(np.load(pcdp))['arr_0']
            bgr = dict(np.load(imp))['arr_0']
            slvless_img = cv2.imread(slvless_imp)

            slvless_img_norm = 255. * slvless_img / (np.linalg.norm(slvless_img, axis=-1)[:, :, None] + 1e-6)
            slvless_img_mask = slvless_img_norm.sum(2) > 0.0

            # replace nan to 0
            if np.isnan(xyz_raw).any():
                xyz = np.nan_to_num(xyz_raw) 
            else:
                xyz = xyz_raw
            xyz_resh = xyz.reshape(-1, 3)
            xyz_color_resh = bgr[:, :, ::-1].reshape(-1, 3) 

            if self.pcd_bkgd_rm:
                sel_inds_frgnd, _ = self._pcd_bkgd_rm(pts=xyz_resh, dist_thresh=self.dist_thresh)
            else:
                sel_inds_frgnd = np.ones(xyz_resh.shape[0]).astype(bool)

            sel_inds = slvless_img_mask.flatten()

            xyz_sel = xyz_resh[sel_inds & sel_inds_frgnd]
            clr_sel = xyz_color_resh[sel_inds & sel_inds_frgnd]
            
            if self.pcd_with_color and self.pcd_with_normals:
                if self.pcd_bkgd_rm:
                    pcd_sdir = osp.join(self.save_base_dir, self._get_seq_name, 'fgnd_xyz_wc_wn')
                else:
                    pcd_sdir = osp.join(self.save_base_dir, self._get_seq_name, 'xyz_wc_wn')
                os.makedirs(pcd_sdir, exist_ok=True)
                fn_pcd = osp.join(pcd_sdir, osp.basename(imp).replace('bgr.npz', 'ply'))
                # compute normals
                xyz_nrmls = self._compute_normals(pts=xyz, rad=0.05, maxnn=10)
                write_ply(fn_pcd, verts=xyz_sel, trias=None, color=clr_sel, normals=xyz_nrmls, binary=False)
            elif self.pcd_with_normals:
                if self.pcd_bkgd_rm:
                    pcd_sdir = osp.join(self.save_base_dir, self._get_seq_name, 'fgnd_xyz_wn')
                else:
                    pcd_sdir = osp.join(self.save_base_dir, self._get_seq_name, 'xyz_wn')
                os.makedirs(pcd_sdir, exist_ok=True)
                fn_pcd = osp.join(pcd_sdir, osp.basename(imp).replace('bgr.npz', 'ply'))
                # compute normals
                xyz_nrmls = self._compute_normals(pts=xyz, rad=0.05, maxnn=10)
                write_ply(fn_pcd, verts=xyz_sel, trias=None, color=None, normals=xyz_nrmls, binary=False)
            elif self.pcd_with_color:
                if self.pcd_bkgd_rm:
                    pcd_sdir = osp.join(self.save_base_dir, self._get_seq_name, 'fgnd_xyz_wc')
                else:
                    pcd_sdir = osp.join(self.save_base_dir, self._get_seq_name, 'xyz_wc')
                os.makedirs(pcd_sdir, exist_ok=True)
                fn_pcd = osp.join(pcd_sdir, osp.basename(imp).replace('bgr.npz', 'ply'))
                write_ply(fn_pcd, verts=xyz_sel, trias=None, color=clr_sel, normals=None, binary=False)
            else:
                if self.pcd_bkgd_rm:
                    pcd_sdir = osp.join(self.save_base_dir, self._get_seq_name, 'fgnd_xyz')
                else:
                    pcd_sdir = osp.join(self.save_base_dir, self._get_seq_name, 'xyz')
                os.makedirs(pcd_sdir, exist_ok=True)
                fn_pcd = osp.join(pcd_sdir, osp.basename(imp).replace('bgr.npz', 'ply'))
                write_ply(fn_pcd, verts=xyz_sel, trias=None, color=None, normals=None, binary=False)

        print('Done!')
        print(f'PCD Save Time: {(time.time() - start):0.4f}s')
        print(f"PCD saved here: {pcd_sdir}")


        return None

    def rm_smlcomps_slvless_img(self,):

        slvless_imgs_dir = osp.join(self.save_base_dir, self.sqn, 'slvless_img')
        slvless_imgs_pths = sorted(glob.glob(osp.join(slvless_imgs_dir, '*.png')))

        for slvless_imp in tqdm(slvless_imgs_pths[self.start_ind : self.end_ind]):
            im = cv2.imread(slvless_imp)
            im_norm = 255. * im / (np.sum(im,axis=-1)[:, :, None] + 1e-6)
            im_mask = (im_norm.sum(2) > 0.0).astype(np.uint8)
            # bb()
            lcc = getLargestCC(im_mask)
            im_lcc = cv2.bitwise_and(im, im, mask=lcc.astype(np.uint8))
            cv2.imwrite(slvless_imp, im_lcc)
        
        return None

    def save_pointclouds(self,):
        "save poinclouds"
        print('Saving PCDs...')
        start = time.time()

        pcds_pths = sorted(glob.glob(osp.join(self.inp_seq_dir, 'pointcloud', '*.xyz.npz')))[self.start_ind : self.end_ind]
        assert len(pcds_pths) > 0, f"No .xyz.npz files in given seq dir:{self.inp_seq_dir}"

        imgs_pths = sorted(glob.glob(osp.join(self.inp_seq_dir, 'pointcloud', '*.bgr.npz')))[self.start_ind : self.end_ind]
        assert len(imgs_pths) > 0, f"No .bgr.npz files in given seq dir:{self.inp_seq_dir}"

        for (pcdp, imp) in tqdm(zip(pcds_pths, imgs_pths)):
            xyz_raw = dict(np.load(pcdp))['arr_0']
            bgr = dict(np.load(imp))['arr_0']
            
            # replace nan to 0
            if np.isnan(xyz_raw).any():
                xyz = np.nan_to_num(xyz_raw) 
            else:
                xyz = xyz_raw
            
            xyz_resh = xyz.reshape(-1, 3)
            xyz_color_resh = bgr[:, :, ::-1].reshape(-1, 3) 

            # if self.pcd_bkgd_rm:
            #     sel_inds, _ = self._pcd_bkgd_rm(pts=xyz_resh, dist_thresh=self.dist_thresh)
            #     xyz_sel = xyz_resh[sel_inds]
            #     clr_sel = xyz_color_resh[sel_inds]
            # else:
            #     xyz_sel = xyz_resh
            #     clr_sel = xyz_color_resh

            if self.pcd_bkgd_rm:
                sel_inds_frgnd, _ = self._pcd_bkgd_rm(pts=xyz_resh, dist_thresh=self.dist_thresh)
            else:
                sel_inds_frgnd = np.ones(xyz_resh.shape[0]).astype(bool)
            
            if self.crop_slv:
                sel_inds_slvless = self.get_slvless_inds(img_pth=imp)
            else:
                sel_inds_slvless = np.ones(xyz_resh.shape[0]).astype(bool)

            xyz_sel = xyz_resh[sel_inds_frgnd & sel_inds_slvless]
            clr_sel = xyz_color_resh[sel_inds_frgnd & sel_inds_slvless]
            
            if self.pcd_with_color and self.pcd_with_normals:
                if self.pcd_bkgd_rm:
                    pcd_sdir = osp.join(self.save_base_dir, self._get_seq_name, 'fgnd_xyz_wc_wn')
                else:
                    pcd_sdir = osp.join(self.save_base_dir, self._get_seq_name, 'xyz_wc_wn')
                os.makedirs(pcd_sdir, exist_ok=True)
                fn_pcd = osp.join(pcd_sdir, osp.basename(imp).replace('bgr.npz', 'ply'))
                # compute normals
                xyz_nrmls = self._compute_normals(pts=xyz, rad=0.05, maxnn=10)
                write_ply(fn_pcd, verts=xyz_sel, trias=None, color=clr_sel, normals=xyz_nrmls, binary=False)
            elif self.pcd_with_normals:
                if self.pcd_bkgd_rm:
                    pcd_sdir = osp.join(self.save_base_dir, self._get_seq_name, 'fgnd_xyz_wn')
                else:
                    pcd_sdir = osp.join(self.save_base_dir, self._get_seq_name, 'xyz_wn')
                os.makedirs(pcd_sdir, exist_ok=True)
                fn_pcd = osp.join(pcd_sdir, osp.basename(imp).replace('bgr.npz', 'ply'))
                # compute normals
                xyz_nrmls = self._compute_normals(pts=xyz, rad=0.05, maxnn=10)
                write_ply(fn_pcd, verts=xyz_sel, trias=None, color=None, normals=xyz_nrmls, binary=False)
            elif self.pcd_with_color:
                if self.pcd_bkgd_rm:
                    pcd_sdir = osp.join(self.save_base_dir, self._get_seq_name, 'fgnd_xyz_wc')
                else:
                    pcd_sdir = osp.join(self.save_base_dir, self._get_seq_name, 'xyz_wc')
                os.makedirs(pcd_sdir, exist_ok=True)
                fn_pcd = osp.join(pcd_sdir, osp.basename(imp).replace('bgr.npz', 'ply'))
                write_ply(fn_pcd, verts=xyz_sel, trias=None, color=clr_sel, normals=None, binary=False)
            else:
                if self.pcd_bkgd_rm:
                    pcd_sdir = osp.join(self.save_base_dir, self._get_seq_name, 'fgnd_xyz')
                else:
                    pcd_sdir = osp.join(self.save_base_dir, self._get_seq_name, 'xyz')
                os.makedirs(pcd_sdir, exist_ok=True)
                fn_pcd = osp.join(pcd_sdir, osp.basename(imp).replace('bgr.npz', 'ply'))
                write_ply(fn_pcd, verts=xyz_sel, trias=None, color=None, normals=None, binary=False)

        print('Done!')
        print(f'PCD Save Time: {(time.time() - start):0.4f}s')
        print(f"PCD saved here: {pcd_sdir}")
        
        return None

    def save_depth_maps(self,):
        "save depth values of each pixels"
        raise NotImplementedError("Depth maps should be computed!")

        return None

    def save_masks(self,):
        "save foreground masks"
        print('Saving masks...')
        start = time.time() 
        # bb()
        mask_sdir = osp.join(self.save_base_dir, self._get_seq_name, 'mask')
        os.makedirs(mask_sdir, exist_ok=True)

        pcds_pths = sorted(glob.glob(osp.join(self.inp_seq_dir, 'pointcloud', '*.xyz.npz')))[self.start_ind : self.end_ind]
        assert len(pcds_pths) > 0, f"No .xyz.npz files in given seq dir:{self.inp_seq_dir}"

        for pcdp in tqdm(pcds_pths):
            xyz_raw = dict(np.load(pcdp))['arr_0']

            # replace nan to 0
            if np.isnan(xyz_raw).any():
                xyz = np.nan_to_num(xyz_raw) 
            else:
                xyz = xyz_raw   
            
            # replace 0 dist with max dist values
            xyz_dist = np.linalg.norm(xyz, axis=2)
            xyz_dist = np.where(xyz_dist==0., xyz_dist.max(), xyz_dist)

            sel_inds =  xyz_dist < self.dist_thresh
            mask = (sel_inds.astype(np.uint8) * 255).reshape(*sel_inds.shape, 1)
            mask_3ch = np.repeat(mask, repeats=3, axis=2)

            fn_mask = osp.join(mask_sdir, osp.basename(pcdp).replace('xyz.npz', 'png'))
            cv2.imwrite(fn_mask, mask_3ch)

        print('Done!')
        print(f'masks Save Time: {(time.time() - start):0.4f}s')
        print(f"masks saved here: {mask_sdir}")

        return None
    
    def save_slvless_masks(self,):
        "segment sleeve/arm and save sleevless/armless masks"
        print('Segmenting and Saving sleevless/armless masks...')
        start = time.time()
        rgbs_dir = osp.join(self.save_base_dir, self._get_seq_name, 'rgb')
        save_seq_dir = osp.join(self.save_base_dir, self._get_seq_name)
        fgnd_masks_dir = osp.join(self.save_base_dir, self._get_seq_name, 'mask')

        slvless_msk_dir = segm_sleeve(rgbs_dir, fgnd_masks_dir, save_seq_dir, self.slv_clr, None, None,
        self.norm_type, self.kms_max_iter, self.kms_eps, self.kms_num_clstrs)
        print('Done!')
        print(f'RGB Save Time: {(time.time() - start):0.4f}s')
        print(f"rgb save here: {slvless_msk_dir}")

        return None

    def save_outlr_rm_pcds(self, sqn, vox_size, radius, num_nibrs):
        print('removing pcds outliers...')
        # # invoke outlr rm script
        # cmd = f"python /gfs-ssd/user/aswamy/github_repos/Dataset-Capture/scripts/outlier_rm.py --inp_pcds_dir /scratch/1/user/aswamy/data/hand-obj/{sqn}/fgnd_xyz_wc --seq_dir /scratch/1/user/aswamy/data/hand-obj/{sqn}"
        # print(cmd)
        # os.system(cmd)
        inp_pcds_dir = f'/scratch/1/user/aswamy/data/hand-obj/{sqn}/fgnd_xyz_wc'
        seq_dir = f'/scratch/1/user/aswamy/data/hand-obj/{sqn}'
        rm_outlier(inp_pcds_dir, seq_dir, vox_size, radius, num_nibrs, down_sample=True, start_ind=self.start_ind, end_ind=self.end_ind)
        print(f"outlier removal done!!")

        return None
    
    def create_rgb_vid(self):
        print('creating rgb video...')
        rgb_imgs_dir = osp.join(self.save_base_dir, self._get_seq_name, 'rgb')
        rgb_vid_fn = osp.join(rgb_imgs_dir, 'vid_rgb.mp4')
        imgs2vid_ffmpeg(rgb_imgs_dir, rgb_vid_fn, ext='png', frm_rate=10)
        print(f"rbg vid saved here: {rgb_vid_fn}")

        return None

    def create_slvless_img_vid(self):
        print('creating slvless img video...')
        slvlss_imgs_dir = osp.join(self.save_base_dir, self._get_seq_name, 'slvless_img')
        slvlss_imgs_vid_fn = osp.join(slvlss_imgs_dir, f'vid_slvless_{self._get_seq_name}.mp4')
        imgs2vid_ffmpeg(slvlss_imgs_dir, slvlss_imgs_vid_fn, ext='png', frm_rate=10)
        print(f"rbg vid saved here: {slvlss_imgs_vid_fn}")

        return None
    

    @property
    def _get_seq_name(self,):
        """
        seq_dir: "../../../seq_name" 
        """
        seq_name = self.inp_seq_dir.rstrip('/').split('/')[-1]

        return seq_name
    
    def _pcd_bkgd_rm(self, pts, dist_thresh):
        "dist_thresh to be set manually for each seq"
        pts = pts.reshape(-1, 3)
        dist = np.linalg.norm(pts, axis=1)
        sel_inds = dist < dist_thresh
        pts_sel = pts[sel_inds]
        
        return sel_inds, pts_sel

    def get_slvless_inds(self, img_pth):
        slvless_msk_pth = osp.join(self.save_base_dir, self._get_seq_name, 'slvless_msk',
         osp.basename(img_pth).replace('bgr.npz', 'png'))
        # armless_msk_pth = img_pth.replace('pointcloud', 'armless_msk').replace('bgr.npz', 'png')
        slvless_msk = cv2.imread(slvless_msk_pth)

        return slvless_msk[:, :, 0].flatten().astype(bool)

    def _compute_normal1s(self, pts, rad=0.05, maxnn=10):
        import open3d as o3d
        pcd_o3d = o3d.geometry.PointCloud()
        pcd_o3d.points = o3d.pybind.utility.Vector3dVector(pts)
        pcd_o3d.estimate_normals(search_param=o3d.geometry.KDTreeSearchParamHybrid(radius=rad, max_nn=maxnn))

        return np.array(pcd_o3d.normals)
    
    def write_seq_info(self):
        "write the config file"
        pass

    def __call__(self):
        if self.save_rgb:
            self.save_rgbs()
        if self.save_pcd:    
            self.save_pointclouds()
        if self.save_depth:
            self.save_depth_maps()
        if self.save_mask:
            self.save_masks()

        return None

if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser("Processing captured raw data")

    parser.add_argument('--inp_seq_dir', type=str, required=True,
                        help='path to the input data dir(dir with *.bgr.npz and *.xyz.npz')
    parser.add_argument('--save_base_dir', type=str, default='/scratch/1/user/aswamy/data/hand-obj',
                        help='base path to save processed data')
    parser.add_argument('--start_ind', type=int, default=None,
                        help='start index of a seq')
    parser.add_argument('--end_ind', type=int, default=None,
                        help='End index of a seq')

    # segm slv args
    parser.add_argument('--norm_type', type=str, default='L2', choices=['L2', 'ratio'],
                        help='norm choice; "L2" or "ratio"')
    parser.add_argument('--kms_max_iter', type=int, default=100,
                        help='k-means max iteration criteria (increases computation time)') 
    parser.add_argument('--kms_eps', type=float, default=0.2,
                        help='k-means accuracy criteria')                        
    parser.add_argument('--kms_num_clstrs', type=int, default=4,
                        help='k-means number of clusters')

    parser.add_argument('--sqn', type=str, default=None,
                            help='seq name')

    # outlier rm args
    parser.add_argument('--vox_size', type=float, default=0.0005,
                        help='voxel size for down sampling')
    parser.add_argument('--radius', type=float, default=0.01,
                        help='outlier search radius of sphere')
    parser.add_argument('--num_nibrs', type=int, default=200,
                        help='min no of points to be present in the sphere for inlier cond.')

    args = parser.parse_args()

    print("args:", args)     

    # sleeve segm parameters
    SLV_COLOR = [128, 204, 77] # normalization color of arm sleeve(observe the segmented image after clustering and then set this)
    # KMEANS_MAX_ITER = 100  # k-means max iteration criteria (increases computation time)
    # KMEANS_EPSILON = 0.2 # k-means accuracy criteria
    # KMEANS_NUM_CLUSTERS = 5 # k-means number of clusters
    
    #run below lines for test
    interface = L515DataInterface(inp_seq_dir=args.inp_seq_dir, save_base_dir=args.save_base_dir,
    save_rgb=True, save_depth=False, save_mask=True, save_pcd=True, pcd_bkgd_rm=True,
    pcd_with_color=True, pcd_with_normals=False, dist_thresh=1.0, crop_slv=True,
    depth_type='dist_xyz', start_ind=args.start_ind, end_ind=args.end_ind, slv_clr=SLV_COLOR,
    norm_type=args.norm_type, kms_max_iter=args.kms_max_iter, kms_eps=args.kms_eps,
    kms_num_clstrs=args.kms_num_clstrs, sqn=args.sqn)
    # bb()
    
    # interface.create_npzs()
    # interface.save_rgbs()
    # interface.save_masks()
    # interface.save_slvless_masks()
    interface.rm_smlcomps_slvless_img()

    # interface.create_slvless_img_vid()

    # interface.save_pointclouds()
    interface.save_pcds_from_slvless_img()
    interface.save_outlr_rm_pcds(args.sqn, args.vox_size, args.radius, args.num_nibrs)
    
    print('Done!!')
